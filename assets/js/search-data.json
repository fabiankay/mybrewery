{
  
    
        "post0": {
            "title": "My learning journey",
            "content": "My learning journey . While planning the mybrewery application and working on our Frunch Infinity project, I learned a lot about developing software in teams. So far my experience was limited to projects as a single developer or product lead without responsibilities towards development practices. Therefore, the experience of working in a team or planning software to be developed by a team was very valueable. My key learnings can be summarized in two main topics, namely planning software for agile projects and test-driven development under time pressure or in larger teams. . Agile Development . . There might be more agile practices and methodologies in place than there are developers on the planet. I’ve read and learned a lot over the past couple of years. I’ve also seen a lot of different development projects. Yet, none of the was the same and all of them claimed to be agile or even SCRUM in one way or the other. To me it seems like every project tailors different concepts and methodologies to suit their needs. This seems ok and might work well for everyone but on the other hand it makes communication much more difficult. By saying “agile” I am now more aware that everyone might see it a little bit different. Therefore, it makes complete sense to outline and define development practices, standards and other artifacts in advance so everyone is on the same page. This helps the team to work efficiently and focus on results rather than processes (as stated in the agile manifesto “individuals and interactions over processes and tools”). . While planning mybrewery I had doubts wether overthinking parts of the software is still in line with agile principles. I started documenting and designing the software without writing a single line of code to test its implementation. As already mentioned within the lecture, coding is only a small fraction of software development. Yet, overthinking the software might lead to a waste of resources when the plan fails or requirements change. Agile principles argue for delivering working software over documentation. I feel like it is hard to balance both aspects since I also see the need for documentation and planning. For example, the class diagram helped me thinking through different options of implementing different ingredients. If I coded my first thought, I would have found myself refactoring the code already during the second iteration. In this case, carefully planning the structure in advance saved a lot of time. . I come to the conclusion that high level planning helps a lot to get a first idea of what’s coming. On the other hand, overplanning things is not helpful either. The critical step is to find the right time to start implementing. For my brewery I am at that point right now. I think a have a good plan to start the first iteration and implement an MVP. It is now the task to reduce the planning to an implementable set of requirements. . Testing . . Another key learning from the projects described is related to test-driven development. The idea sounds great and I haven’t worked with test-driven development a lot. I remember the times when we tried to implement it in our company - we faced similar issues to what I experienced in our projects. When time becomes a topic, tests come last and production code is the priority. Moreover, during development it is also hard to keep tests up-to-date and requirements change over time. . In those cases I understand the priorities. On the other hand, when shipping code to production that is untested (at least in terms of code test coverage), there is this strange feeling if everything unchanged is still working. This feeling was present in our Frunch Infinity project. We had an okay test coverage. Yet, some parts of the software were not covered by tests. After every push there was a short feeling of uncertainty. . Having 100% test coverage seems unreal to me. But having the most important parts of the software covered establishes a comfortable feeling. . At the beginning of the course I felt like I had some experience with software development. But after doing both projects I quickly realized that practicing on real-life projects always leads to new learnings. .",
            "url": "https://fabiankay.github.io/mybrewery/reflection/2022/07/10/my-learning-journey.html",
            "relUrl": "/reflection/2022/07/10/my-learning-journey.html",
            "date": " • Jul 10, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Data Flow diagram",
            "content": "Data Flow diagram . . The Data Flow Diagram above shows the flow of information during a brewing session. It helped understanding the data access and exchange required during different stages of the process. In combination with the software’s architecture, it gets clear where APIs or other access points for data exchange need to be established between different parts of the software. For example the recipe data is stored in another database than the sensor data. .",
            "url": "https://fabiankay.github.io/mybrewery/diagram/2022/06/30/data-flow-diagram-copy.html",
            "relUrl": "/diagram/2022/06/30/data-flow-diagram-copy.html",
            "date": " • Jun 30, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Sequenz diagram",
            "content": "Sequenz diagram . . A sequence diagram shows the behaviour of and the interaction between differnt objects in a software. The diagram helps the user to understand the sequenze and results of actions during the process described. The sequenz diagram above shows the interaction of the brewing session with the user, the temperature sensor and the heater. The brewing session and the recipe define a target temperature. During the session, the temperature recorded from the sensor is compared to the target temperature. Depending on the outcome, the heater is turned on or off. All the information gathered is reported to the user and stored in the database. The whole sequence is ordered chronologically. . Drawing the sequence diagram really helped understanding the timely dependence of certain steps in the process. Generally, the learning from this and the diagrams before is that they can help communicating the idea in a standardized way and think about different implementation strategies without investing too much time into coding. Yet, keeping up all modelling rules and drawing a complete representation of the software is also very time consuming and for some parts feels like overhead. .",
            "url": "https://fabiankay.github.io/mybrewery/diagram/2022/06/18/sequenz-diagram.html",
            "relUrl": "/diagram/2022/06/18/sequenz-diagram.html",
            "date": " • Jun 18, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "Class diagram",
            "content": "UML diagram . . The UML Class Diagram demonstrates a partly complete implementation of the brewing application. The focus of this part in the mybrewery ecosystem focuses on the creation and management of beer recipes. Moreover, the brewing application initiates new brewing sessions. The diagram shows the main functions for each class. One essential part of the diagram are the enumerations for certain attributes. To manage the complexity of the application, the specification of some options in advance is highly benefitial. . For the ingredients, the first iteration used enumeration as well. During the second itertion of the diagram, the enumeration was replaced by an inheritance pattern where all ingredients inherit from a ingredients parent class. One reason for this decision was the ability to implement different attributes for the ingredients. This would have caused problems when using enumerations. .",
            "url": "https://fabiankay.github.io/mybrewery/diagram/2022/06/15/uml.html",
            "relUrl": "/diagram/2022/06/15/uml.html",
            "date": " • Jun 15, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "Software architecture diagram",
            "content": "Software architecture diagram . . For mybrewery a microservice arcitecture is proposed. The requirements of the system require the system to perform different tasks that might benefit from independent choices of technologies used. In a microservice architecture the processing of sensor data can use a different tech stack than the web application for the community or the brewing application. Moreover, in a larger team, members with different skill sets can work on each service. This, on the other hand, can also turn out to be a downside of a microservice architecture. Using several different technologies results in an overhead and larger teams since more specialists are needed. . Edge Devices (Sensors) . Edge devices like the temperature sensors in the brewing devices can benefit from a highly specialized architecture. Cloud services like Microsoft Azure provide specialized services that handle the processing of a continuous data flow in a highly efficient manner. In terms of cost, cloud services might be a little bit more expensive, but they are billed by usage. Assuming that mybrewery is targeted at hobby brewers, there is no constant need for such a service. It is only needed while brewing which justifies higher costs per usage instead of constant but slightly lower costs. . For now the software requires a constant flow of data from the temperature sensors while brewing. The data should be processed and monitored to see if the temperature is in a predefined range. For later analysis the data must be stored in a database. Since only the series of temperatures is of interest, the service is built on a Key Value Store to ensure efficient storage and easy analysis. Since internet cannot be ensured 100% of the time, a fall back strategy like local preprocessing and a storage to keep the data from one brewing process as back up is needed. The connected brewing application device should ensure a back up storage. . Brewing Application . The brewing application should be available as native application on any mobile device. The app should use proprietary hardware of the device to connect to any edge sensor and exchange data. Moreover, the when connected to the internet, the application connects to the applications server to manage the brewing recipes and transfer the data from the ongoing or previous brewing session. The recipe data is stored in a relational database on the server. The technologies used for the app can be web technologies. There are several ways to provide web apps as native apps. Since development resources are limited the focus of the brewing application should be iPads as portable device. . Web Application (Community) . The web application can be added in a later stage of the project. It is used to let the community (family and friends of the brewer) rate different brews. The results of the rating and comments should be stored in a relational database system and linked to the data from the brewing process. Whether or not the data is stored in the same database as the data from the brewing application needs to be evaluated. The brewing application has other requirements concerning availability and performance. Therefore, the seperation of both databases is proposed to ensure best performance for both systems. Whenever a new brew is finished in the brewing application, the information needed (name, style, …) can be moved to the community database. Data consistency can be neglected and synchronisations times are not essential. As a prefered alternative an Application Programming Interface (API) is implemented. Moreover, the seperation is also in line with the microservice philosophy. . Data Storage &amp; Analytics . A lot on storage technologies has already been mentioned above. There will be a Key Value Store for sensor data and relational databases for both, the brewing application and the community website. While all databases might exchange some information via API, the data will remain within the service as single source of truth. For analytics purposes like for example the taste ratings and comments or temperture curves, the data form all databases will be integrated into the analytics service. Data from different services can be connected using the brewing session id. . For tracking brewing sessions the logging of different actions, especially the interactions with other parts of the software seems appropriate or even necessary. Whenever the edge device application returns values or the brewing session triggers a change in temperature, the respective information should be logged to a logfile. Moreover, any manual interference with the heater should be logged. Yet, logging should not be exaggerated and only be applied in critical processes and for tracking error states. .",
            "url": "https://fabiankay.github.io/mybrewery/diagram/2022/06/15/architecture-diagram.html",
            "relUrl": "/diagram/2022/06/15/architecture-diagram.html",
            "date": " • Jun 15, 2022"
        }
        
    
  
    
        ,"post5": {
            "title": "Development process",
            "content": "Development process . Since the development team size for the project proposed is currently between 1 and 2 developers, a lightweight development process is proposed. . Agile development . For the first itereation, a set of requirements to create an easy to use recipe manager is selected. In daily update meetings (acc. to SCRUM principles), the 2 developer update each other on their respectiv progress and issues. For critical parts of the software pair programming sessions are planned. Moreover, to ensure smooth operations and the capability to extend the developer team, a continous development pipeline is developed. The project uses the Github plattform and Github Actions and pipelines to automate testing and later on deployment. When coding standards are established, it should also be feasible to open source the project. For branching Gitflow should be used. This way it should be easy to track feature progress and release cycles. . Test-driven . For the development of the main brewing application, a test-driven agile approach is proposed. The core features of the minimal viable product (MVP) are covered with several different unit tests. As proposed for test-driven development, the tests are developed in advance and production code is only written to pass the tests. For the tests, unit tests to test single units of the software, like for example core functions, and integration tests to aggregate the functionality of several different parts of the software are written. For example it makes sense to test the time calculation fonction for each brewing step (unit test) and the creation of a whole recipe where different classes anf components of the software interact (integration test). . The following example shows a unit test for the time calulations of a brewing step . class BrewingStep: time = 0 def set_time(self, time): self.time = time return self.time def get_time(self): return self.time def add_time(self, time): self.time += time return self.time if __name__ == &#39;__main__&#39;: step = BrewingStep() . import BrewingStep as BrewingStep class Test(unittest.TestCase): &quot;&quot;&quot; The basic class that inherits unittest.TestCase &quot;&quot;&quot; step = BrewingStep.BrewingStep() time = 0 # test case function to check the BrewingStep.set_time function def test_0_set_time(self): print(&quot;Start set_time test n&quot;) self.time = self.step.set_time(10) self.assertEqual(self.time, 10) self.time = self.step.add_time(10) self.assertEqual(self.time, 20) print(&quot; nFinish set_time test n&quot;) # test case function to check the BrewingStep.get_time function def test_1_get_time(self): print(&quot; nStart get_time test n&quot;) self.assertEqual(self.step.get_time, self.time) print(&quot; nFinish get_time test n&quot;) if __name__ == &#39;__main__&#39;: # begin the unittest.main() unittest.main() .",
            "url": "https://fabiankay.github.io/mybrewery/process/2022/06/10/development.html",
            "relUrl": "/process/2022/06/10/development.html",
            "date": " • Jun 10, 2022"
        }
        
    
  
    
        ,"post6": {
            "title": "Requirements",
            "content": "Requirements . Functional Requirements . The application must be able to plan the brewing process. The user must be able to select the type of beer he/she wants to brew. | The user must be able to select the amount of grains he/she wants to use. | The user must be able to select the amount of water he/she wants to use. | The user must be able to select the amount of yeast he/she wants to use. | The user must be able to select the amount of hops he/she wants to use. | The user must be able to select the amount of time he/she wants to spend brewing. | The user must be able to specify each ingredient’s quantity. | The user must be able to define the different steps of the brewing process and the time each step takes. | The user must be able to add a note to the brewing process. | The user must be able to save the brewing process. | The user must be able to load a previously saved brewing process. | The user should be able to see a list of all saved brewing processes. | The user should be able to delete a previously saved brewing process. | The user should be able to specify the name of the beer. | The user should be able to specify the type of malt used. | The user should be able to specify the type of hops used. | . | The application must be able to monitor the brewing process. The user must be able to see the current step of the brewing process. | The user must be able to see the remaining time for the current step of the brewing process. | The user must be able to see the current temperature of the brewing process. | The user should be able to see the amount of ingredients needed for the current step. | The user should be able to see the next step of the brewing process. | The user should be able to see the amount of ingredients needed for the next step. | . | The application must be able to document the brewing process. The application must store all the information collected during the brewing process. | The collected data must be available for every brewing process. | The user must be able to add comments for each step. | The user should be able to comment or add tasting notes. | The user should be able to rate the beer after the brewing. | . | . Technological Requirements . The collected data must be stored accessible and persistent. | Edge sensors (f.e. temperature sensors) must be integrated so they can be exchanged or extended easily. | Users must authenticate before using the application. | The application must work without internet connection. | The application should provide users the option to share their brewing processes publicly or privately. | . Quality of Service . The application must be available through all common internet browsers in their latest version. | The application should be available on tablet devices. | . User Interface Requirements . The temperature data should be available as line chart. | The user must be able to access and see the data collected during the brewing process in a human readable way. | The application should be responsive and optimized for tablet usage. | The application could have a dark mode (because everything cool should have a dark mode ;) ). | . Legal and contractual Requirements . The application must support measurement units for the following: Liquid volume in liters | Weight in kilograms | Temperature in degrees Celsius | Time in minutes | Gravity in SG | . | The application must be available in english. | The application should be available in german. | . Changes of requirements . Requirements can change rapidly. Therefore, having a plan how to deal with changes is essential for ongoing success. To effectively deal with changing requirements, it helps to classify and document changes regardless of their “size”. For this project I propose categorizing any changing requirements by the following factors: . severity (high, medium, low) | source (internal, external) | effect (effected part of the software) | reason/description (for documentation) | result/decision (add, adapt, remove) | . Depending on the classification of changing requirement, different processes should be applied. For severe external as well as external changes the project team should decide how to incorporate the change immediately. For less severe changes the team should decide after the current iteration. For non severe changes individuals or the team in charge of the effected part of the application may decide. . Potential changes might come from covering other “markets” in terms of localization. F.e. for US usage, the units and calculations need to be adapted. Moreover, some speciality beer styles might require special types of ingredients (flavoring) or additional steps (dry-hopping). .",
            "url": "https://fabiankay.github.io/mybrewery/requirements/2022/05/29/requirements.html",
            "relUrl": "/requirements/2022/05/29/requirements.html",
            "date": " • May 29, 2022"
        }
        
    
  
    
        ,"post7": {
            "title": "Brewing 101",
            "content": "How does brewing work? . To better understand the application and the requirements it aims to address, the following secion will briefly walk you through the brewing process and important parameters during each step. . 1. Preparation After carefully cleaning the equipment (a kattle, a large spoon, pipes and valves, …) it is time to weight the grains. For brewing we use crushed malt of different types. . 2. Mash In The grains are first mashed in a large bowl. Water is heated to a certain temperature and the grains are added to the water. It is important to keep the water at a specific temperature during the mash in process. The water temperature should be monitored and the water should be heated again if necessary. The water is then filtered to remove the impuritys. . 3. Sparge water Additional water is added and drained through the mash tun. . 4. Boil After the mash out the water is heated until it is boiling. The water should boil for an exact amount of time between 60 and 90 minutes. At certain points in time we add hops to the water. Depending on the type of beer we add different hops at different points in time. . 5. Fermentation Fermentation is the process of converting the young beer into alcohol. By adding yeast to the filtered young beer after boiling in step 4, the remaining sugar is converted into alcohol. Now we let the young beer rest until it is ready to be filled into bottles. The right time to fill the bottles is reached when the remaining sugar is at a certain level (again depending on the type of beer). . 6. Bottling Before botteling we add glucose to the fermented beer. We fill the beer to bottles and we label them with the name of the beer. After another 1-4 weeks the beer is ready to be consumed. . 7. Enjoy :) . Important parameters . Temerature | Time | Measurements (water, malt, hops, yeast, …) | Gravity | .",
            "url": "https://fabiankay.github.io/mybrewery/intro/2022/05/28/brewing101.html",
            "relUrl": "/intro/2022/05/28/brewing101.html",
            "date": " • May 28, 2022"
        }
        
    
  
    
        ,"post8": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://fabiankay.github.io/mybrewery/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This project is developed by Fabian Kainz. .",
          "url": "https://fabiankay.github.io/mybrewery/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://fabiankay.github.io/mybrewery/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}